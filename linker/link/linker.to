use elf

class Linker
{
	# map[string]SegList
	seglists
	# arr[SymLink*]
	symLinks
	# arr[SymLink*]
	symDef
	# arr[elf,elf,elf]
	elfs
	# 链接关心的段
	segNames
	# File* 最后输出的文件
	exe
	# 拥有全局符号start _start的文件
	startOwner
	bssaddr
	bytes
}
# 初始化
Linker::Linker()
{
	this.segNames[] = ".text"
	this.segNames[] = ".data"
	this.segNames[] = ".roadata"
	this.segNames[] = ".data.rel.local"
	this.segNames[] = ".bss"
	for(name : segNames){
		this.seglists[name] = new Seglist()
	}
}
# 1. 解析elf文件
# 2. 追加到待链接数组中等待链接
Linker::addElf(obj)
{
	e = new elf.File()
	# 解析elf文件
	e.readElf(obj)
	this.elfs[] = e
}

# 开始扫描文件搜集所有信息
Linker::collectInfo()
{
	for(e : this.elfs){
		# 记录段表信息
		for(seg : segNames){
			if  e.shdrTab[seg] {
				tmp = this.segLists[seg].ownerList
				tmp[] = e
			}
		}
		# 记录符号引用信息
		for(name,sym<elf.Elf64_Sym> : e.symTab){
			symLink = new SymLink()
			symLink.name = name
			if  sym.st_shndx == STN_UNDEF {
				symLink.recv = e
				symLink.prov = null
				this.symLinks[] = symLink
			}
			if  sym.st_shndx != SHN_ABS {
				symLink.prov = e
				symLink.recv = null
				this.symDef[] = symLink
			}

		}
	}

}

Linker::symValid()
{
	flag = true
	startOwner = null
	#TODO: 支持 k,v 通过参数引用的方式来获迭代数据
	for(i,def : this.symDef){
		sym<elf.Elf64_Sym> = def.prov.symTab[def.name]
		# 只支持全局符号
		if   elf.ELF64_ST_BIND(sym.st_info)  != STB_GLOBAL {
			continue
		}
		if  def.name == "mini_crt_entry" {
			startOwner = def.prov
		}
		for(j = i + 1 ; j < std.len(this.symDef); j += 1){
			sym = this.symDef[j].prov.symTab[this.symDef[j].name]
			if   elf.ELF64_ST_BIND(sym.st_info)  != STB_GLOBAL {
				continue
			}
			# 同名符号 有冲突
			if  def.name == this.symDef[j].name {
				fmt.println("符号名:%s在文件%s和文件%三种功能发生定义冲突 ",def.name,def.prov.elf_dir,
				this.symDef[j].prov.elf_dir)
				flag = false
			}
		}
	}
	if  startOwner == null {
		fmt.println("链接器找不到入口:mini_crt_entry")
		falg = false
	}
	# 遍历未定义的符号
	for(link : this.symLinks){
		for(def : this.symDef){
			# 同名符号
			if  link.name == def.name {
				link.prov = def.prov
				def.recv = def.prov
			}
		}
		if  link.prov == null {
			msym<elf.Elf64_Sym> = link.recv.symTab[link.name]
			info<u8> = msym.st_info
			type = ""
			if   elf.ELF64_ST_TYPE(info)  == STT_OBJECT {
				type = "变量"
			}
			if   elf.ELF64_ST_TYPE(info)  == STT_FUNC {
				type = "函数"
			}
			if  type == "" {
				type = "符号"
			}
			fmt.println("文件%s的%s名%s为定义",link.recv.elf_dir,type,link.name)
			if  flag {
				flag = false
			}
		}
	}
	return flag
}

# 分配地址空间
Linker::allocAddr()
{
	curAddr = BASE_ADDR
	curOff = sizeof(elf.Elf64_Ehdr) + sizeof(elf.Elf64_Phdr) * std.len(segNames)

	for(seg : this.segNames){
		this.segLists[seg].allocAddr(seg,curAddr,curOff)
	}
	bssaddr = curAddr
}

Linker::symParser()
{
	for(def : this.symDef){
		sym<elf.Elf64_Sym> = def.prov.symTab[def.name]
		segName = ""
		if  sym.st_shndx == SHN_COMMON {
			segName = ".bss"
		}else{
			segName = def.prov.shdrNames[sym.st_shndx]
		}
		if  segName == ".bss" && def.name != ".bss" {
			bssaddr += sym.st_size
			sym.st_value = bssaddr
		}else{
			sh<elf.Elf64_Shdr> = def.prov.shdrTab[segName]
			sym.st_value = sym.st_value + sh.sh_addr
		}
	}
	for(syml : this.symLinks){
		provsym<elf.Elf64_Sym> = syml.prov.symTab[syml.name]
		recvsym<elf.Elf64_Sym> = syml.recv.symTab[syml.name]
		recvsym.st_value = provsym.st_value
	}
}

# 重定位
Linker::relocate()
{
	for(e : elf.elfs){
		tab = e.relTab
		for(t : tab){
			if  t.relname == "" {
				continue
			}
			symname = t.relname
			sym<elf.Elf64_Sym> = e.symTab[symname]
			rel<elf.Elf64_Rela> = t.rel
			sh<elf.Elf64_Shdr> = e.shdrTab[t.segname]
			file = e.elf_dir
			symAddr = sym.st_value + rel.r_addend
			relAddr = sh.sh_addr + rel.r_offset
			# 开始重定位操作
			this.segLists[t.segname].relocaAddr(relAddr,elf.ELF64_R_TYPE(rel.r_info),symAddrrel.r_addend)
		}
	}
}