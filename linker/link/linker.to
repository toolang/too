use elf

#统计读写的字节数
bytes

class Linker
{
	seglists		# map[string]SegList
	symLinks		# arr[SymLink*]
	symDef			# arr[SymLink*]
	elfs			# arr[elf,elf,elf]
	segNames		# arr[string] 链接关心的段
	exe				# File* 最后输出的文件
	startOwner		# 拥有全局符号start _start的文件
	bssaddr
	bytes
}
Linker::init(){
	this.segNames = []
	this.bssaddr  = 0
	this.elfs = []
	this.symLinks = []
	this.symDef   = []

	this.linker()
}
# 初始化
Linker::linker()
{
	this.segNames[] = ".text"
	this.segNames[] = ".data"
	this.segNames[] = ".roadata"
	this.segNames[] = ".data.rel.local"
	this.segNames[] = ".bss"
	for(name : segNames){
		this.seglists[name] = new Seglist()
	}
}
# 1. 解析elf文件
# 2. 追加到待链接数组中等待链接
Linker::addElf(obj)
{
	e = new elf.File()
	# 解析elf文件
	e.readElf(obj)
	this.elfs[] = e
}

# 开始扫描文件搜集所有信息
Linker::collectInfo()
{
	for(e : this.elfs){
		fmt.println("collect elf info:",e.elfdir)
		# 记录段表信息
		for(seg : this.segNames){
			if  e.shdrTab[seg] {
				tmp = this.segLists[seg].ownerList
				# TODO: copy on write 
				tmp[] = e
			}
		}
		# 记录符号引用信息
		for(name,sym<elf.Elf64_Sym> : e.symTab){
			symLink = new SymLink()
			symLink.name = name
			if  sym.st_shndx == STN_UNDEF {
				fmt.println(name, " 未定义 ")
				symLink.recv = e
				symLink.prov = null
				this.symLinks[] = symLink
			}
			if  sym.st_shndx != SHN_ABS {
				fmt.println(name, " 已定义")
				symLink.prov = e
				symLink.recv = null
				this.symDef[] = symLink
			}

		}
	}

}

Linker::symValid()
{
	flag = true
	startOwner = null
	#TODO: 支持 k,v 通过参数引用的方式来获迭代数据
	for(i,def : this.symDef){
		sym<elf.Elf64_Sym> = def.prov.symTab[def.name]
		# 只支持全局符号
		if   elf.ELF64_ST_BIND(sym.st_info)  != STB_GLOBAL {
			fmt.println(def.name + " 非全局符号")
			continue
		}
		if  def.name == "main" {
			startOwner = def.prov
		}
		for(j = i + 1 ; j < std.len(this.symDef); j += 1){
			sym = this.symDef[j].prov.symTab[this.symDef[j].name]
			if   elf.ELF64_ST_BIND(sym.st_info)  != STB_GLOBAL {
				continue
			}
			# 同名符号 有冲突
			if  def.name == this.symDef[j].name {
				fmt.println("符号名:%s在文件%s和文件%三种功能发生定义冲突 ",def.name,def.prov.elf_dir,
				this.symDef[j].prov.elf_dir)
				flag = false
			}
		}
	}
	if  startOwner == null {
		fmt.println("链接器找不到入口: main")
		flag = false
	}
	# 遍历未定义的符号
	for(link : this.symLinks){
		for(def : this.symDef){
			# 同名符号
			if  link.name == def.name {
				link.prov = def.prov
				def.recv = def.prov
			}
		}
		if  link.prov == null {
			msym<elf.Elf64_Sym> = link.recv.symTab[link.name]
			info<u8> = msym.st_info
			type = ""
			if   elf.ELF64_ST_TYPE(info)  == STT_OBJECT {
				type = "变量"
			}
			if   elf.ELF64_ST_TYPE(info)  == STT_FUNC {
				type = "函数"
			}
			if  type == "" {
				type = "符号"
			}
			fmt.println("文件%s的%s名%s为定义",link.recv.elf_dir,type,link.name)
			if  flag {
				flag = false
			}
		}
	}
	return flag
}

# 分配地址空间
Linker::allocAddr()
{
	curAddr<i32> = BASE_ADDR
	curOff = int(sizeof(elf.Elf64_Ehdr)) + int(sizeof(elf.Elf64_Phdr)) * std.len(segNames)

	for(seg : this.segNames){
		this.segLists[seg].allocAddr(seg,&curAddr,*curOff)
	}
	this.bssaddr = int(curAddr)
}

Linker::symParser()
{
	fmt.println("符号解析")
	for(def : this.symDef){
		sym<elf.Elf64_Sym> = def.prov.symTab[def.name]
		segName = ""
		if  sym.st_shndx == SHN_COMMON {
			segName = ".bss"
		}else{
			segName = def.prov.shdrNames[int(sym.st_shndx)]
		}
		if  segName == ".bss" && def.name != ".bss" {
			this.bssaddr += int(sym.st_size)
			sym.st_value = *this.bssaddr
		}else{
			sh<elf.Elf64_Shdr> = def.prov.shdrTab[segName]
			sym.st_value = sym.st_value + sh.sh_addr
		}
	}
	fmt.println("未定义符号解析")
	for(syml : this.symLinks){
		provsym<elf.Elf64_Sym> = syml.prov.symTab[syml.name]
		recvsym<elf.Elf64_Sym> = syml.recv.symTab[syml.name]
		recvsym.st_value = provsym.st_value
	}
}

# 重定位
Linker::relocate()
{
	fmt.println("重定位")
	for(e : elf.elfs){
		//TODO: copy on write
		tab = e.relTab
		for(t : tab){
			if  t.relname == "" {
				continue
			}
			symname = t.relname
			sym<elf.Elf64_Sym> = e.symTab[symname]
			rel<elf.Elf64_Rela> = t.rel
			sh<elf.Elf64_Shdr> = e.shdrTab[t.segname]
			file = e.elf_dir
			symAddr<u32> = sym.st_value + rel.r_addend
			relAddr<u32> = sh.sh_addr + rel.r_offset
			# 开始重定位操作
			this.segLists[t.segname].relocaAddr(relAddr,elf.ELF64_R_TYPE(rel.r_info),symAddr,rel.r_addend)
		}
	}
}