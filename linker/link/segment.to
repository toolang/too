class Seglist
{
	baseAddr   # 分配基地址
	offset     # 合并后的文件偏移
	size	   # 合并后的大小
	begin  	   # 对齐前开始位置偏移
	ownerList  # array[ElfFile] 
	blocks	   # array[block]
}

# @param name string 段名	
# @param off 文件偏移地址
# @param base 加载基地址
Seglist::allocAddr(name,base,off)
{
	begin = off; # 记录文件前偏移
	# 虚拟地址对齐，让所有的段按照4k字节对其
	if  name != ".bss" {
		base += (MEM_ALIGN-base % MEM_ALIGN) % MEM_ALIGN
	}
	# 偏移第一对齐，让一般段按照4字节对齐，文本段16字节对齐
	align = DISC_ALIGN
	if  name == ".text" {
		align = 16
	}
	off += (align - off % align) % align

	# 使虚地址和偏移按照 4k摸去余
	base = base - base % MEM_ALIGN + off % MEM_ALIGN
	//累加地址和偏移
	baseAddr = base
	offset = off
	size = 0
	for( i = 0 ; i < len(this.ownerList) ; i += 1){
		# 对齐每个小段，按照4字节
		size += (DISC_ALIGN - size % DISC_ALIGN) % DISC_ALIGN
		seg = ownerList[i].shdrTab[name]
		# 读取需要合并段段数据
		if  name != ".bss" {
			buf = 
		}
	}
}

# relAddr: 重定位虚拟地址
# type: 重定位类型
# symAddr: 重定位符号的虚拟地址
Seglist::relocAddr(relAddr,type,symAddr,addend)
{
	relOffset = relAddr - baseAddr
	#查找带修正的地址所在pos
	b
	for(i = 0 ; i < len(blocks) ; i += 1){
		if  blocks[i].offset <= relOffset && blocks[i].offset + blocks[i].size > relOffset {
			b = blocks[i]
			break
		}
	}
	# 这里需要进行内存寻址
	base<i8> = b.data
	paddr<ui8> = base + relOffset - b.offset

 	if  type == 42 {
		inst<ui8> = paddr
		inst -= 1
		modr<ui8> = inst
		inst -= 1
		opcode<ui8> = inst
		# TODO: 针对struct类型 可以通过* 进行内存跳级访问
		if  *opcode == 0x8b {
			reg = (*modr - 0x05)/8
			*opcode = 0xc0 + reg
		}
		*paddr = symAddr - addend
		return
	}
	if type == R_X86_64_PC32)
	{
		*paddr = symAddr - relAddr + *paddr
		return
	}
	if  type == R_X86_64_PLT32 {
		*paddr = symAddr - relAddr + *paddr
		return
	}
	if  type == R_X86_64_64 {
		*paddr = symAddr - addend
		return
	}
	fmt.println("unknow rela")
}