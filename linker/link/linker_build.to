use std
use fmt
use os
use elf

Linker::buildExe()
{
	fmt.println("Linker::buildExe ")
	exe = this.exe

	ehdr<elf.Elf64_Ehdr> = exe.ehdr
	#  获取变量的地址
	pid<i32*> = &ehdr.e_ident
	*pid  = 0x464c457f
	pid += 4
	*pid = 0x010102
	pid += 4
	*pid = 0
	pid += 4
	*pid = 0

	ehdr.e_type = elf.ET_EXEC
	ehdr.e_machine = elf.EM_X86_64
	ehdr.e_version = elf.EV_CURRENT
	ehdr.e_flags = 0
	ehdr.e_ehsize = sizeof(elf.Elf64_Ehdr)

	#curOff = sizeof(elf.Elf64_Ehdr) + sizeof(elf.Elf64_Phdr) * std.len(this.segNames)
	curOff = int(sizeof(elf.Elf64_Ehdr)) + int(sizeof(elf.Elf64_Phdr)) * std.len(this.segNames)
	# 空段表
	zero = 0
	exe.addShdr("",zero,zero,zero,zero,zero,zero,zero,zero,zero)

	shstrtabSize = 26
	for(seg : this.segNames){
		# 每个字符串末尾自动加上结束符号 \0
		shstrtabSize += std.len(seg) + 1

		flags<i32> = elf.PF_W | elf.PF_R
		filesz = this.segLists[seg].size
		if  seg == ".text" {
			flags = elf.PF_X | elf.PF_R
		}
		if  seg == ".bss"  {
			filesz = 0
		}
		# 添加程序头表
		exe.addPhdr(int(elf.PT_LOAD),
			this.segLists[seg].offset,
			this.segLists[seg].baseAddr,
			filesz,
			this.segLists[seg].size,
			int(flags),
			int(MEM_ALIGN)
		)
		# 计算有效数据段的大小和偏移
		curOff = this.segLists[seg].offset
		#生成段表项
		sh_type = int(elf.SHT_PROGBITS)
		sh_flags<i32> = elf.SHF_ALLOC | elf.SHF_WRITE
		sh_align = 4
		if  seg == ".bss" {
			sh_type = int(elf.SHT_NOBITS)
		}
		if  seg == ".text" {
			sh_flags = elf.SHF_ALLOC | elf.SHF_EXECINSTR
			sh_align = 16
		}
		# 添加一个段表项，暂时按照4字节对齐
		exe.addShdr(seg,sh_type,int(sh_flags),
			this.segLists[seg].baseAddr,
			this.segLists[seg].offset,
			this.segLists[seg].size,
			int(elf.SHN_UNDEF),0,sh_align,0
		)
	}
	ehdr.e_phoff = sizeof(elf.Elf64_Ehdr)
	ehdr.e_phentsize = sizeof(elf.Elf64_Phdr)
	segnames_len = std.len(segNames)
	ehdr.e_phnum = *segnames_len

	# 初始化一段字符串内存
	strsize<i32> = *shstrtabSize
	str<u8*> = new strsize
	strp<u8*> = str
	exe.shstrtabSize = shstrtabSize

	index = 0
	# 段表船名于索引映射
	shstrIndex = {}
	shstrIndex[".shstrtab"] = index
	std.strcopy(strp,*".shstrtab") strp += 10
	index += 10

	shstrIndex[".symtab"] = index
	std.strcopy(strp,*".symtab")   strp += 8
	index += 8

	shstrIndex[".strtab"] = index
	std.strcopy(strp,*".strtab")   strp += 8
	index += 8
	shstrIndex[""] = index - 1

	for(i : this.segNames){
		shstrIndex[i] = index
		std.strcopy(strp,*i)
		il = std.len(i) + 1
		ill<i32> = *il
		strp += ill
		index += il
	}
	exe.shstrtab = str
	exe.addShdr(".shstrtab",int(elf.SHT_STRTAB),0,0,curOff,shstrtabSize,int(elf.SHN_UNDEF),0,1,0)
	shstrtab_idx = exe.getSegIndex(".shstrtab")
	ehdr.e_shstrndx = *shstrtab_idx

	# 段表偏移
	curOff += shstrtabSize
	ehdr.e_shoff = *curOff
	ehdr.e_shentsize = sizeof(elf.Elf64_Shdr)
	sec_lens = 4 + std.len(segNames)
	ehdr.e_shnum = *sec_lens
	curOff  += int(sizeof(elf.Elf64_Shdr)) * sec_lens

	eas = 1 + std.len(symDef)	
	eas *= int(sizeof(elf.Elf64_Sym))
	exe.addShdr(".symtab",int(elf.SHT_SYMTAB),0,0,curOff,eas,0,0,1,int(sizeof(elf.Elf64_Sym)))
	symtab<elf.Elf64_Shdr> = exe.shdrTab[".symtab"]
	symtab.sh_link = exe.getSegIndex(".symtab") + 1
	strtabSize = 0
	exe.addSym("",0)

	#遍历所有符号
	for(def : this.symDef){
		name = def.name
		strtabSize += std.len(name) + 1
		sym<elf.Elf64_Sym> = def.prov.symTab[name]
		ndx = null
		if  sym.st_shndx == elf.SHN_COMMON {
			ndx = exe.getSegIndex(".bss")
		}else{
			ndx = exe.getSegIndex(def.prov.shdrNames[int(sym.st_shndx)])
		}
		sym.st_shndx = *ndx
		exe.addSym(name,sym)
	}

	#记录程序入口
	start<elf.Elf64_Sym> = exe.symTab["main"]
	ehdr.e_entry = start.st_value
	#curOff += (1 + std.len(this.symDef)) * sizeof(elf.Elf64_Sym)
	ts = std.len(this.symDef) + 1
	curOff += ts * int(sizeof(elf.Elf64_Sym))
	exe.addShdr(".strtab",int(elf.SHT_STRTAB),0,0,curOff,strtabSize,int(elf.SHN_UNDEF),0,1,0)
	exe.strtabSize = strtabSize
	index = 0
	strIndex = {}
	strIndex[""] = strtabSize - 1
	for(sd : this.symDef){
		exe.strtab += sd.name + "\0"
		index += std.len(sd.name) + 1
	}
	for(kname,st<elf.Elf64_Sym> : exe.symTab){
		st.st_name = strIndex[kname]
	}
	#更新段表name
	for(sname,sh<elf.Elf64_Shdr> : exe.shdrTab){
		si = shstrIndex[sname]
		sh.sh_name = *si
	}

}

Linker::writeExe(out)
{
	fmt.println("Linker::writeExe")
	exe = this.exe
    ehdr<elf.Elf64_Ehdr> = exe.ehdr
	offset = exe.writeHeader(out)
	slen = int(sizeof(elf.Elf64_Ehdr)) + std.len(exe.phdrTab) * int(sizeof(elf.Elf64_Phdr))
	fmt.assert(offset,slen,"Linker::writeExe")
	fp = io.fopen(out,"a+")
	pad<i8*> = 0
	one<i8> = 1
	for(seg : this.segNames){
		sl = this.segLists[seg]
		padnum = sl.offset - sl.begin
		offset += padnum
		while padnum {
			padnum -= 1
			io.fwrite(fp,&pad,one)
		}
		#输出
		if  seg != ".bss" {
			old<Block> = null
			instPad<i8*> = 0x90
			for(b<Block> : sl.blocks){
				if  old != null {

					padnum<i32> = b.offset - old.offset + old.size
					offset += int(padnum)
					while padnum {
						padnum -= 1
						io.fwrite(fp,&instPad,one)
					}
				}
				old = b
				offset += int(b.size)
				io.fwrite(fp,b.data,b.size)
			}
		}
	}
	io.fclose(fp)
	sts<elf.Elf64_Shdr> = exe.shdrTab[".shstrtab"]
	if  offset != int(sts.sh_offset) {
		fmt.println("ofsset")
		os.exit(-1)
	}
	offset += exe.shstrtabSize
	if  offset != int(ehdr.e_shoff) {
		fmt.println("ofsset")
		os.exit(-1)
	}
	exe.writeSecSym(out)
}

Linker::link(out)
{
	fmt.println("Linker::link")
	this.collectInfo()
	if   !this.symValid() {
		return false
	}
	this.allocAddr()
	this.symParser()
	this.relocate()
	this.buildExe()
	this.writeExe(out)
	return true
}