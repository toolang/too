use std
use fmt
use os
use elf

Linker::buildExe()
{
	fmt.println("build exe")
	exe = this.exe
	ehdr<elf.Elf64_Ehdr> = exe.ehdr
	#  获取变量的地址
	pid<i> = &ehdr.e_ident
	*pid  = 0x464c457f
	pid += 1
	*pid = 0x010102
	pid += 1
	*pid = 0
	pid += 1
	*pid = 0

	ehdr.e_type = elf.ET_EXEC
	ehdr.e_machine = elf.EM_X86_64
	ehdr.e_version = elf.EV_CURRENT
	ehdr.e_flags = 0
	ehdr.e_ehsize = sizeof(elf.Elf64_Ehdr)

	#curOff = sizeof(elf.Elf64_Ehdr) + sizeof(elf.Elf64_Phdr) * std.len(this.segNames)
	curOff = int(sizeof(elf.Elf64_Ehdr)) + int(sizeof(elf.Elf64_Phdr)) * std.len(this.segNames)
	# 空段表
	this.exe.addShdr("",0,0,0,0,0,0,0,0,0)

	shstrtabSize = 26
	for(seg : this.segNames){
		# 每个字符串末尾自动加上结束符号 \0
		shstrtabSize += std.len(seg) + 1

		flags<i32> = PF_W | PF_R
		filesz = this.segLists[seg].size
		if  seg == ".text" {
			flags = PF_X | PF_R
		}
		if  seg == ".bss"  {
			filesz = 0
		}
		# 添加程序头表
		this.exe.addPhdr(PT_LOAD,
			this.segLists[seg].offset,
			this.segLists[seg].baseAddr,
			filesz,
			this.segLists[seg].size,
			flags,
			MEM_ALIGN
		)
		# 计算有效数据段的大小和偏移
		curOff = this.segLists[seg].offset
		#生成段表项
		sh_type = SHT_PROGBITS
		sh_flags = SHF_ALLOC | SHF_WRITE
		sh_align = 4
		if  seg == ".bss" {
			sh_type = SHT_NOBITS
		}
		if  seg == ".text" {
			sh_flags = SHF_ALLOC |SHF_EXECINSTR
			sh_align = 16
		}
		# 添加一个段表项，暂时按照4字节对齐
		this.exe.addShdr(seg,sh_type,sh_flags,
			this.segLists[seg].baseAddr,
			this.segLists[seg].offset,
			this.segLists[seg].size,
			SHN_UNDEF,0,sh_align,0
		)
	}
	ehdr.e_phoff = sizeof(elf.Elf64_Ehdr)
	ehdr.e_phentsize = sizeof(elf.Elf64_Phdr)
	ehdr.e_phnum = std.len(segNames)

	# 初始化一段字符串内存
	str = ""
	exe.shstrtab = *str
	exe.shstrtabSize = shstrtabSize

	index = 0
	# 段表船名于索引映射
	shstrIndex = {}
	shstrIndex[".shstrtab"] = index
	str += ".shstrtab"
	index += 10
	shstrIndex[".symtab"] = index
	str += ".symtab"
	index += 8
	shstrIndex[".strtab"] = index
	str += ".strtab"
	index += 8
	shstrIndex[""] = index - 1

	for(i : this.segNames){
		shstrIndex[i] = index
		#str += i + "\0"
		str += i 
		index += std.len(i) + 1
	}

	exe.addShdr(".shstrtab",SHT_STRTAB,0,0,curOff,shstrtabSize,SHN_UNDEF,0,1,0)
	ehdr.e_shstrndx = exe.getSegIndex(".shstrtab")

	# 段表偏移
	curOff += shstrtabSize
	ehdr.e_shoff = curOff
	ehdr.e_shentsize = sizeof(elf.Elf64_Shdr)
	ehdr.e_shnum = 4 + std.len(segNames)
	curOff  += sizeof(elf.Elf64_Shdr) * (4 + std.len(this.segNames))

	eas = 1 + std.len(symDef)	
	eas *= int(sizeof(elf.Elf64_Sym))
	exe.addShdr("symtab",SHT_SYMTAB,0,0,curOff,eas,0,0,1,sizeof(elf.Elf64_Sym))
	symtab<elf.Elf64_Shdr> = exe.shdrTab[".symtab"]
	symtab.sh_link = exe.getSegIndex(".symtab") + 1
	strtabSize = 0
	exe.addSym("",0)

	#遍历所有符号
	for(def : this.symDef){
		name = def.name
		strtabSize += std.len(name) + 1
		sym<elf.Elf64_Sym> = def.prov.symTab[name]
		if  sym.st_shndx == SHN_COMMON {
			sym.st_shndx = exe.getSegIndex(".bss")
		}else{
			sym.st_shndx = exe.getSegIndex(def.prov.shdrNames[sym.st_shndx])
		}
		exe.addSym(name,sym)

		#记录程序入口
		start<elf.Elf64_Sym> = exe.symTab[START]
		ehdr.e_entry = start.st_value
		#curOff += (1 + std.len(this.symDef)) * sizeof(elf.Elf64_Sym)
		ts = std.len(this.symDef) + 1
		curOff += ts * sizeof(elf.Elf64_Sym)
		exe.addShdr(".strtab",SHT_STRTAB,0,0,curOff,strtabSize,SHU_UNDEF,0,1,0)
		
		exe.strtabSize = strtabSize
		index =0
		strIndex = {}
		strIndex[""] = strtabSize - 1
		for(sd : this.symDef){
			strIndex[sd.name] = index
			exe.strtab += sd.name + "\0"
			index += std.len(sd.name) + 1
		}
		for(name,st<elf.Elf64_Sym> : exe.symTab){
			st.st_name = strIndex[name]
		}
		#更新段表name
		for(name,sh<elf.Elf64_Shdr> : exe.shdrTab){
			sh.sh_name = shstrIndex[name]
		}

	}
}

Linker::writeExe(out)
{
	exe = this.exe
	offset = exe.writeHeader(out)
	slen = int(sizeof(elf.Elf64_Ehdr)) + std.len(exe.phdrTab) * int(sizeof(elf.Elf64_Phdr))
	fmt.assert(offset,slen,"Linker::writeExe")
	fp = io.fopen(out,"a+")
	pad = 0
	for(seg : this.segNames){
		sl = this.segLists[seg]
		padnum = sl.offset - sl.begin
		offset += padnum
		while padnum {
			padnum -= 1
			io.fwrite(pad,1,1,fp)
		}
		#输出
		if  seg != ".bss" {
			old = null
			instPad = 0x90
			for(b : sl.blocks){
				if  old != null {
					padnum = b.offset - (old.offset + old.size)
					offset += padnum
					while padnum {
						padnum -= 1
						io.fwrite(instPad,1,1,fp)
					}
				}
				old = b
				offset += b.size
				io.fwrite(b.data,b.size,1,fp)
			}
		}
	}
	io.fclose(fp)
	sts<elf.Elf64_Shdr> = exe.shdrTab[".shstrtab"]
	if  offset != sts.sh_offset {
		fmt.println("ofsset")
		os.exit(-1)
	}
	offset += exe.shstrtabSize
	if  offset != ehdr.e_shoff {
		fmt.println("ofsset")
		os.exit(-1)
	}
	exe.writeSecSym(out)
}

Linker::link(out)
{
	this.collectInfo()
	if   !this.symValid() {
		return false
	}
	this.allocAddr()
	this.symParser()
	this.relocate()
	this.buildExe()
	this.writeExe(out)
	return true
}