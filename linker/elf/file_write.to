
use std
use io
use fmt
# 写入header头
# 写入程序表头
File::writeHeader(out) 
{
    fmt.println("write header")
    ehdr<Elf64_Ehdr> = this.ehdr
    bytes = 0

	fp = io.fopen(out,"w+")
    bytes += int(ehdr.e_ehsize)

	# elf文件头
    io.fwrite(fp,ehdr,ehdr.e_ehsize)

    if std.len(phdrTab) != 0 {  //程序头表
        for (phd : phdrTab) {
            bytes += int(ehdr.e_phentsize)
			# 写入程序表头
            io.fwrite(fp,phd,ehdr.e_phentsize)
        }
    }
    io.fclose(fp)
	return bytes
}

# 1. 写入段表 + 段字符串表
# 2. 写入符号表 + 符号字符串表
File::writeSecSym(out) 
{
    bytes = 0
    ehdr<Elf64_Ehdr> = this.ehdr
    shstrtabSize<i32> = this.shstrtabSize
    strtabSize<i3w>  = this.strtabSize

    fp = io.fopen(out,"a+")
    bytes += int(shstrtabSize)
    #字符串段表: 写入所有关于段名的字符串 .shstrtab
    io.fwrite(fp,shstrtab,shstrtabSize)
    #段表: 写入所有段
    for(i = 0;i < std.len(this.shdrNames); i += 1)
    {
		sh = this.shdrTab[this.shdrNames[i]]
        bytes += int(ehdr.e_shentsize)
        io.fwrite(fp,sh,ehdr.e_shentsize)
    }
    #符号表: 写入所有符号
    Elf64_Sym_Size<i8> = sizeof(Elf64_Sym)
    for(i = 0;i < std.len(symNames) ; i += 1)
    {
		sym = this.symTab[this.symNames[i]]
        bytes += int(Elf64_Sym_Size)
        io.fwrite(fp,sym,Elf64_Sym_Size)
    }
    # 字符串表: 写入所有字符串
    bytes += int(strtabSize)
    io.fwrite(fp,strtab,strtabSize)
    io.fclose(fp)
    return bytes
}

