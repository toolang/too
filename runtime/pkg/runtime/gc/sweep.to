
extern u64 get_sp()
extern u64 get_bp()
extern u64 get_di()
extern u64 get_si()
extern u64 get_dx()
extern u64 get_cx()
extern u64 get_r8()
extern u64 get_r9()
extern u64 get_bp()
extern u64 get_ax()
extern u64 get_bx()
extern void free()
extern void mark()
extern void stringmark()

func gc_mark(ptr<u64*>)
{
    if ptr == Null return True

    po<pool>  = pool_addr(ptr)
    areobj<arena> = *arenas
    if po < areobj.address || po > areobj.address + ARENA_SIZE {
        // mark(&Hugmem,ptr)
        return NOT_STACK
    }
    if in_heap(ptr,po) != True {
        // mark(&Hugmem,ptr)
        return NOT_STACK
    }

    size<i32> = index2size(po.szidx)

    hdr<block> = ptr - 8
    if hdr.mask == BLOCK_MASK {
        if hdr.flags < 1 || hdr.flags > 3     return True
        if flag_test(hdr,FLAG_ALLOC) == False return True
        if flag_test(hdr,FLAG_MARK) == True   return True
        flag_set(hdr,FLAG_MARK)
    }
    for (p<u64*> = ptr ; p < ptr + size - 8 ; p += 1) {
        if gc_mark(*p) == NOT_STACK {
            _.mark(hugmem,*p)
        }
    }
    return True
}
func gc_sweep()
{

    area<arena> = *arenas 

    for (p<u64> = area.first_address ; p < area.pool_address ; p += POOL_SIZE)
    {
        po<pool> = p

        size<i32> = index2size(po.szidx)
        start_addr<u64> = p + POOL_OVERHEAD
        end_addr<u64>   = p + POOL_SIZE

        for (pp<u64> = start_addr ; pp < end_addr ; pp += size)
        {
            obj<block> = pp
            if flag_test(obj,FLAG_ALLOC) == True 
            {
                if flag_test(obj,FLAG_MARK) == True 
                    flag_unset(obj,FLAG_MARK)
                else {
                    flag_unset(obj,FLAG_ALLOC)
                    _.free(pp)
                }
            }
        }
    }
}
func tell_is_stackarg(arg<u64*>){
    if arg == null return True
    top<u64> = _.get_sp()
    if spstart > arg  && arg > top {
        if gc_mark(*arg) == NOT_STACK {
            _.mark(hugmem,*arg)
        }
    }
}
func scan_register()
{
    reg = _.get_sp()  tell_is_stackarg(reg)
    reg = _.get_bp()  tell_is_stackarg(reg)
    reg = _.get_di()  tell_is_stackarg(reg)
    reg = _.get_si()  tell_is_stackarg(reg)
    reg = _.get_dx()  tell_is_stackarg(reg)
    reg = _.get_cx()  tell_is_stackarg(reg)
    reg = _.get_r8()  tell_is_stackarg(reg)
    reg = _.get_r9()  tell_is_stackarg(reg)
    reg = _.get_ax()  tell_is_stackarg(reg)
    reg = _.get_bx()  tell_is_stackarg(reg)
}
func scan_stack(){
    cur_sp<u64*> = _.get_sp()
    if spstart < cur_sp {
        os.die("spstart should >= cur_sp")
    }

    for ( cur_sp ;cur_sp < spstart ; cur_sp += 2){
        ptr<u64> = *cur_sp
        v<value> = ptr
        hdr<block> = ptr - 8
        po<pool> = pool_addr(ptr)
        areobj<arena> = *arenas 
        if po < areobj.address || po > areobj.address + ARENA_SIZE {
            continue
        }
        if in_heap(ptr,po) == False {
            continue
        }
        if hdr.flags < 1 || hdr.flags > 3 {
            _.stringmark(ptr)
            continue
        }
        if v.type == String {
            //TODO: fix 会有 type=string data=1的情况
            _.stringmark(v.data)
        }
        if gc_mark(ptr) == NOT_STACK {
            _.mark(hugmem,ptr)
        }
    }
}
func gc()
{
    scan_register()
    scan_stack()

    gc_sweep()
}

