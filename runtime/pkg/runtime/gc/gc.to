
// 内存分配器
// 分配策略:
// 1. 小内存就用当前的分配器 分配block
// 2. 超过256bytes就进行系统malloc调用
//
// 3. 下面有一个循环链表，多链表，加快内存分配
// ----------------------------------------------------------------
//    1-8                     8                       0
//	  9-16                   16                       1
//	 17-24                   24                       2
//	 25-32                   32                       3
//	 33-40                   40                       4
//	 41-48                   48                       5
//	 49-56                   56                       6
//	 57-64                   64                       7
//	 65-72                   72                       8
//	  ...                   ...                     ...
//	241-248                 248                      30
//	249-256                 256                      31
//
// 64 * 8 个内存空间
pools<u64*>
maxarenas<u32>
arenas<u64*>
unused_arena_objects<u64*>
usable_arenas<arena>
narenas_currently_allocated<u64*>
hugmem<u64*>
spstart<u64*>

//macro
ALIGNMENT<i32> 		= 8
ALIGNMENT_SHIFT<i32> = 3
ALIGNMENT_MASK<i32>  = 7

SMALL_THRESHOLD<i32> = 256
SMALL_CLASSES<i32>  = 32
SYSTEM_PAGE_SIZE<i32> = 4096
SYSTEM_PAGE_SIZE_MASK<i32> = 4095

ARENA_SIZE<i32> = 262144 # 256 << 20 256kb
POOL_SIZE<i32>  = 4096
POOL_SIZE_MASK<i32> = 4095

BLOCK_MASK<i32> = 1234567
POOL_OVERHEAD<i32> = 48
DUMMY_SIZE_IDX<i32> = 65535
NOT_STACK<i8>     = 10
INITIAL_ARENA_OBJECTS<i8> = 16


mem block {
	i32 flags
	i32 mask
	u64* addr
}

mem pool {
	u8* 		ref # _padding,count
	block*  	freeblock
	pool* 		nextpool
	pool* 		prevpool
	u32			arenaindex
	u32			szidx
	u32 		nextoffset
	u32			maxnextoffset
} 
mem arena {
	u64 	address
	u8*		first_address
	u8* 	pool_address
	u32 	nfreepools
	u32 	ntotalpools

	pool* 	freepools
	arena*	nextarena
	arena*	prevarena
}
func index2size(i<u32>){
	ret<u32> = i + 1
	ret <<= ALIGMENT_SHIFT
	return ret
}

func numblocks(i<u64>){
	ret<u32> = POOL_SIZE - POOL_OVERHEAD	
	return ret / index2size(i)
}

func pool_addr(p<u64>){
	psm<u64> = POOL_SIZE_MASK
	return p & ~psm
}
func pta(x<i32>){
	p<u64> = 2 * x * 8
	p 	  += pools
	p 	  -= 2 * 8
	return p
}
func in_heap(p<u64>,po<pool>){
	areobj<arena> = arenas + po.arenaindex * 8
	adr<u64> = areobj.address
	return po.arenaindex < maxarenas && p - adr < ARENA_SIZE && adr != null
}

FLAG_ALLOC<i8> = 1
FLAG_MARK<i8>  = 2
func flag_set(b<block>,f<u64>){
	b.flags |= f
}
func flag_unset(b<block>,f<u64>){
	b.flags &= ~f
}
func flag_test(b<block>,f<u64>){
	return b.flags & f
}
func is_marked(p<u64>){
	l<i8> = flag_test(p,FLAG_ALLOC)
	r<i8> = flag_test(p,FLAG_MARK)
	if l && r return True
	else return False
}
func getpool(i<i32>){
	p<u64*> = pools + i*8
	return *p
}
func getarena(i<i32>){
	return arenas + i * sizeof(arena)
}